Chord generalidad:

Es un protocolo basado en DHT, que puede tener uso en aplicaciones que necesitan distribuir datos y buscarlos posteriormente en una red Peer-to-Peer.

Hashing:

A cada nodo se le asigna un identificador de m bits usando SHA-1
A cada key se le asigna un identificador de m bits usando SHA-1
A cada nodo se le obtiene su identificador mediante su IP
A cada llave se le obtiene su identificador mediante el hash de la misma
Los identificadores son ordenados en un anillo modulo 2^m
La llave k es asignada a un nodo tal que su identificador es igual a ella o sigue a k en el orden de identificadores. El nodo es llamado el nodo sucesor de la llave k. Si es un anillo, el sucesor es el primer nodo "en el sentido horario" desde k
Join: El nodo que entra, se lleva las llaves que le corresponden de su sucesor
Leave: El nodo sucesor del que sale, se lleva las llaves que tenia el que salio

Posicionamiento de las llaves:
Para mantener una busqueda completa, es necesario que cada nodo solo conozca a su nodo sucesor, pero para agilizar la busqueda, en cada nodo se mantiene una lista de m otros nodos, esta tabla se le llama finger table.
Finger Table:
Posee m otros nodos
Posee [Identificador de nodo | IP nodo]
Imagen -> Explicar imagen

Join en detalle:
Cada nodo es responsable de las llaves hacia atrás, considerando los identificadores ordenados por magnitud y en un anillo
	Algoritmo:
	- Inicializar el predecesor y la fingerTable del nodo que ingresa
	- Actualizar el predecesor y la fingerTable del nodo que ingresa con la informacion actual del overlay
	- Notificar al sistema de software superior que se agrega otro nodo que es responsable por un intervalo de llave

Función de estabilización:

Cuando se hace un Join de forma activa se hace un update forzado a los datos que posee el nodo que entra, pero es necesario para el resto de los nodos hacer un proceso de actualización recurrente en el tiempo, para esto se define la función de estabilización que se realiza cada cierto intervalo de tiempo y que actualiza los predecesores, los sucesores y la fingerTable de cada uno de los nodos en la red.

Fallas y replicas:

Falla: Cuando se hace un routing y un nodo n, ya no se encuentra disponible

Replicas: Se encarga la capa superior de software

